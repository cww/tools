#!/usr/bin/perl
#
# The MIT License (MIT)
#
# Copyright (c) 2014, 2015 Colin Wetherbee
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

use common::sense;

use List::MoreUtils qw(any);

use constant FILENAME => 'blackholes.txt';
use constant MIN_NETMASK => 8;
use constant MAX_NETMASK => 27;

# Minimum ratio of bad IPs to good IPs within a range in order to trigger a
# report
use constant THRESHOLD => 0.1;

sub num_to_ip4 {
    my ($num) = @_;
    return join(q{.}, map { ($num >> (24 - 8 * $_)) & 0xff } (0 .. 3));
}

sub ip4_to_num {
    my ($ip) = @_;
    my ($a, $b, $c, $d) = split(/\./, $ip);
    return ($a << 24) | ($b << 16) | ($c << 8) | $d;
}

my $fh;
open($fh, '<', FILENAME) or die $!;

my %ips;
my %masks;
for my $ip (<$fh>) {
    chomp $ip;
    next unless $ip =~ /^\d+\.\d+\.\d+\.\d+$/;
    my $num = ip4_to_num($ip);
    my @maskednums = map { $num >> (32 - $_) } (MIN_NETMASK .. MAX_NETMASK);
    $ips{$ip} = {
        num         => $num,
        maskednums  => \@maskednums,
    };
    for (my $i = MIN_NETMASK; $i <= MAX_NETMASK; ++$i) {
        ++$masks{$i}{$maskednums[$i - MIN_NETMASK]};
    }
}
close($fh);

for my $netmask (sort { $a <=> $b } keys %masks) {
    my $max_count = 2 ** (32 - $netmask);
    for my $maskednum (sort { $a <=> $b } keys %{$masks{$netmask}}) {
        my $count = $masks{$netmask}{$maskednum};
        if ($count / $max_count >= THRESHOLD) {
            my $network = num_to_ip4($maskednum << (32 - $netmask));
            say "$network/$netmask (found $count of $max_count):";
            for my $ip (sort { $ips{$a}{num} <=> $ips{$b}{num} }
                        grep { $ips{$_}{maskednums}[$netmask - MIN_NETMASK] == $maskednum } keys %ips) {
                say "  $ip";
            }
        }
    }
}
