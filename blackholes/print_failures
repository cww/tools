#!/usr/bin/perl
#
# The MIT License (MIT)
#
# Copyright (c) 2013 Colin Wetherbee
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
###########################################################################
#
# authfail /var/log/auth.log
# authfail /var/log/auth.log{,.1} blackholes.txt
# zcat /var/log/auth.log.2.gz | authfail

use common::sense;

use List::MoreUtils qw(uniq);
use Net::DNS;

use constant IP4_RE => qr/^\d+\.\d+\.\d+\.\d+/;

sub open_log
{
    my ($filename) = @_;

    my $fh;
    open($fh, '<', $filename) or
        die "unable to open file $filename";
    return $fh;
}

sub close_log
{
    my ($fh) = @_;
    close($fh);
}

sub parse_log
{
    my ($file_ref) = @_;

    sub add_ips
    {
        my ($line, $ips_ref, @ips) = @_;

        for (@ips)
        {
            if (!defined($_) || $_ =~ /^0/ || $_ eq q{})
            {
                say STDERR "Unable to resolve host '$_' from line: $line";
                exit 2;
            }
            else
            {
                undef $ips_ref->{$_};
            }
        }
    }

    my $fh = $file_ref->{fh};
    my %ips;
    while (my $line = <$fh>)
    {
        chomp $line;

        # Check keyword(s).
        if ($line =~ /fail/i &&
            $line !~ /Too many authentication failures/ &&
            $line !~ /Connection reset by peer/ &&
            $line !~ /\bsshd\[\d+\]:.*connect_to.*failed/ &&
            $line !~ /\bsshd\[\d+\]:.*channel.*open failed/ &&
            $line !~ /\bsu\[\d+\]: /)
        {
            if ($line =~ /rhost=(\S+)/ || $line =~ /from\s+(\S+)/)
            {
                my $parsed = $1;
                my @new_ips = $parsed =~ /^${+IP4_RE}$/ ?
                              ($parsed) :
                              get_ips($parsed);
                add_ips($line, \%ips, @new_ips);
            }
            elsif ($line =~ /\s(\S+)\s+\[(\S+)\]\s+failed/)
            {
                my ($parsed_hostname, $parsed_ip) = ($1, $2);
                my @hostname_ips = get_ips($parsed_hostname);
                add_ips($line, \%ips, @hostname_ips, $parsed_ip);
            }
            else
            {
                say "Unable to parse failure candidate: $line";
            }
        }
        # Also support lines that are only IP addresses.  Preserve netmasks,
        # too.
        elsif ($line =~ m|^${+IP4_RE}(?:/\d+)?$|)
        {
            add_ips($line, \%ips, $line);
        }
    }

    my @keys = keys %ips;
    return \@keys;
}

# Resolve a hostname into an IP address.
#
# Returns a list of IP addresses.
my $_res = Net::DNS::Resolver->new();
sub get_ips
{
    my ($hostname);

    my @ips;
    my $q = $_res->search($hostname);
    if ($q)
    {
        for my $rr ($q->answer())
        {
            given ($rr->type())
            {
                when (q{A}) { continue; }
                when (q{AAAA})
                {
                    my $address = $rr->address();
                    if ($address)
                    {
                        push(@ips, $address);
                    }
                    else
                    {
                        say STDERR "Unable to resolve: $hostname";
                        exit 2;
                    }
                }
            }
        }
    }

    return @ips;
}

# Sorted by octet/hexatet; IPv4 addresses come before IPv6 addresses in sort
# order.
sub sort_func
{
    # IPv4
    if ($a =~ IP4_RE && $b =~ IP4_RE)
    {
        my @a_octets = split(/\./, $a);
        my @b_octets = split(/\./, $b);

        for (my $i = 0; $i < 4; ++$i)
        {
            return -1 if $a_octets[$i] < $b_octets[$i];
            return  1 if $a_octets[$i] > $b_octets[$i];
        }
    }
    # XXX Check IPv6 addresses, too.

    # IPs are equivalent.
    return 0;
}

sub run
{
    my (@filenames) = @_;

    # Open log files.
    my @files;
    for my $filename (@filenames)
    {
        my %file =
        (
            filename => $filename,
            fh => open_log($filename),
        );
        push(@files, \%file);
    }
    if (! -t *STDIN)
    {
        push(@files, { filename => 'stdin', fh => *STDIN });
    }

    if (@files == 0)
    {
        say 'No files to process';
        exit 1;
    }

    # Parse and process log files.
    my @ips;
    for my $file_ref (@files)
    {
        my $new_ips_ref = parse_log($file_ref);
        push(@ips, @$new_ips_ref);
    }
    @ips = sort sort_func uniq(@ips);

    # Close log files.
    for my $file_ref (@files)
    {
        close_log($file_ref->{fh});
    }

    # Output.
    for my $ip (@ips)
    {
        say $ip;
    }
}

run(@ARGV);
